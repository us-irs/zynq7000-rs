//! # Rust peripheral acess crate to the AMD Zynq 7000 SoCs
//!
//! This crate provides a low-level register access API building on the
//! [`derive-mmio` crate](https://crates.io/crates/derive-mmio). However, its structure
//! is similar to the crates auto-generated by [`svd2rust`](https://docs.rs/svd2rust/latest/svd2rust/#peripheral-api).
//!
//! This crate is purposely kept low-level to allow building higher level abstractions like HALs
//! on top of it.
//! [The Zynq7000 HAL library](https://egit.irs.uni-stuttgart.de/rust/zynq7000-rs/src/branch/main/zynq/zynq7000-hal)
//! contains such a HAL which builds on this PAC.
#![no_std]
#![cfg_attr(docsrs, feature(doc_cfg))]

use core::sync::atomic::{AtomicBool, Ordering};

#[cfg(test)]
extern crate std;

pub const MPCORE_BASE_ADDR: usize = 0xF8F0_0000;

pub mod ddrc;
pub mod devcfg;
pub mod eth;
pub mod gic;
pub mod gpio;
pub mod gtc;
pub mod i2c;
pub mod l2_cache;
pub mod mpcore;
pub mod priv_tim;
pub mod qspi;
pub mod slcr;
pub mod spi;
pub mod ttc;
pub mod uart;
pub mod sdio;
pub mod xadc;

static PERIPHERALS_TAKEN: AtomicBool = AtomicBool::new(false);

/// This is a collection of processing system peripherals.
///
/// It is a singleton which exposes peripherals supported by this crate.
/// The [`svd2rust` documentation](https://docs.rs/svd2rust/latest/svd2rust/#peripheral-api)
/// provides some more information about this.
pub struct Peripherals {
    pub gicc: gic::MmioCpuInterfaceRegisters<'static>,
    pub gicd: gic::MmioDistributorRegisters<'static>,
    pub l2c: l2_cache::MmioRegisters<'static>,
    pub ddrc: ddrc::MmioRegisters<'static>,
    pub uart_0: uart::MmioRegisters<'static>,
    pub uart_1: uart::MmioRegisters<'static>,
    pub spi_0: spi::MmioRegisters<'static>,
    pub spi_1: spi::MmioRegisters<'static>,
    pub i2c_0: i2c::MmioRegisters<'static>,
    pub i2c_1: i2c::MmioRegisters<'static>,
    pub gtc: gtc::MmioRegisters<'static>,
    pub gpio: gpio::MmioRegisters<'static>,
    pub slcr: slcr::MmioRegisters<'static>,
    pub ttc_0: ttc::MmioRegisters<'static>,
    pub ttc_1: ttc::MmioRegisters<'static>,
    pub eth_0: eth::MmioRegisters<'static>,
    pub eth_1: eth::MmioRegisters<'static>,
    pub qspi: qspi::MmioRegisters<'static>,
    pub devcfg: devcfg::MmioRegisters<'static>,
    pub xadc: xadc::MmioRegisters<'static>,
}

impl Peripherals {
    /// Returns all supported processing system peripherals *once*.
    pub fn take() -> Option<Self> {
        let taken = PERIPHERALS_TAKEN.swap(true, Ordering::Relaxed);
        if taken {
            return None;
        }
        Some(unsafe { Self::steal() })
    }

    /// Unchecked version of [Self::take].
    ///
    /// # Safety
    ///
    /// Each of the returned peripherals must be used at most once.
    pub unsafe fn steal() -> Self {
        unsafe {
            Self {
                gicc: gic::CpuInterfaceRegisters::new_mmio_fixed(),
                gicd: gic::DistributorRegisters::new_mmio_fixed(),
                l2c: l2_cache::Registers::new_mmio_fixed(),
                ddrc: ddrc::Registers::new_mmio_fixed(),
                uart_0: uart::Registers::new_mmio_fixed_0(),
                uart_1: uart::Registers::new_mmio_fixed_1(),
                gtc: gtc::Registers::new_mmio_fixed(),
                gpio: gpio::Registers::new_mmio_fixed(),
                slcr: slcr::Registers::new_mmio_fixed(),
                spi_0: spi::Registers::new_mmio_fixed_0(),
                spi_1: spi::Registers::new_mmio_fixed_1(),
                i2c_0: i2c::Registers::new_mmio_fixed_0(),
                i2c_1: i2c::Registers::new_mmio_fixed_1(),
                ttc_0: ttc::Registers::new_mmio_fixed_0(),
                ttc_1: ttc::Registers::new_mmio_fixed_1(),
                eth_0: eth::Registers::new_mmio_fixed_0(),
                eth_1: eth::Registers::new_mmio_fixed_1(),
                qspi: qspi::Registers::new_mmio_fixed(),
                devcfg: devcfg::Registers::new_mmio_fixed(),
                xadc: xadc::Registers::new_mmio_fixed(),
            }
        }
    }
}

#[bitbybit::bitenum(u1, exhaustive = true)]
#[derive(Debug, PartialEq, Eq)]
pub enum SpiClockPhase {
    ActiveOutsideOfWord = 0,
    InactiveOutsideOfWord = 1,
}

#[bitbybit::bitenum(u1, exhaustive = true)]
#[derive(Debug, PartialEq, Eq)]
pub enum SpiClockPolarity {
    QuiescentLow = 0,
    QuiescentHigh = 1,
}
